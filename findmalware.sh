#!/bin/bash
#
# findmalware.sh - A script to guess presence of malware in php files.
# Copyright Â© 2018 Lucio Crusca <lucio@sulweb.org>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# {{{STARTHELP}}}
# # findmalware
# A script that tries to guess presence of malicious code in PHP files. <br/>
# It does NOT look for known malware code fragments, but it uses a set 
# of rules to infer what pieces PHP code are likely malware. As such it 
# produces many false positives, so it uses a whitelist to avoid showing 
# files that are known to be good.
#
# It analyzes every file whose name ends in '.php' looking for them
# recursively in the current directory, so you usually cd into the root
# directory of a PHP website and then you run this script there.
#
# _Please note that this script does **NOT** delete nor sanitize **ANYTHING**.  
# It only produces a report. It's up to the sysadmin (e.g. YOU) to read that 
# report and take action_. <br/>
# As such, it is safe to run this script anywhere you like: it won't even 
# notice if you run it in a read-only filesystem, as long as you have a working 
# mktemp installed and provide appropriate arguments for the lists.
#
# ### Installation:
# This script depends on the following tools
# 1. mktemp
# 2. GNU find
# 3. GNU grep
# 4. GNU sed
# 5. GNU screen
# 6. sha512
# 7. curl for the autoupdate feature
# 8. maybe a bunch of other rather common system commands
# 
# You need to ensure those commands are installed for this script to work. <br/>
# Please note that this script does not check if those commands are 
# available, so failing to install them beforehand can produce undefined
# results.
#
# ### Usage:
#   findmalware.sh [ -c _config-file_ ] [ -b _local-blacklist-file_ ]  <br/>
#     [ -B _upstream-blacklist-file_ ] [ -w _local-whitelist-file_ ]  <br/>
#     [ -W _upstream-whitelist-file_ ] [ -r _local-rules-file_ ]  <br/>
#     [ -R _upstream-rules-file_ ] [ -u _upstream-url_ ]  <br/>
#     [ -e extensions_list ] [ -a ] [ -A ] [ -h ] [ -m ]  <br/>
#
#   where
#
#   -c _config-file_  <br/>
#        Specifies a custom configuration file to load after the 
#        default ones. Every configuration file is a bash fragment that
#        this script includes untouched. This option is parsed before
#        other options, so that command line arguments can override any
#        settings in configuration files. Default configuration files
#        that are ALWAYS loaded if readable, whether you use this option
#        or not, are:
#          * /etc/findmalware.conf
#          * /usr/local/etc/findmalware.conf
#          * $HOME/.findmalware.conf
#          * $HOME/.config/findmalware.conf
#          * $HOME/.findmalware/config
#        in that order. If you specify a custom configuration file and
#        that file is not readable, the script aborts execution by
#        design. The FINDMALWARE\_CONFIG environment variable can be 
#        used instead of this option, but if both are specified, this
#        option takes precedence.
# 
#  -b _local-blacklist-file_  <br/>
#        specifies a blacklist file to use as a cache. This file needs 
#        to be writeable in order to be of any use. However you can
#        live without it, it's really only a way to avoid showing two
#        suspect files when they have exactly the same content and the
#        user has alreay tagged the first one as suspect. A local
#        blacklist can save you quite some time if you scan for malware
#        a directory that contains a website and one or more of its 
#        backups. <br/>
#        It defaults to $HOME/.findmalware/blacklist.local
#
#   -B _upstream-blacklist-file_ <br/>
#        same as -b, but it specifies a local copy of a upstream 
#        blacklist, possibly downloaded from the internet. This can be
#        a read-only file, but if you use the autoupdate feature 
#        (-a option), then this file and its parent directory need
#        to be writeable for you to blacklist anything. <br/>
#        It defaults to $HOME/.findmalware/blacklist
#
#   -w _local-whitelist-file_ <br/>
#        specifies a whitelist file to use as a cache. For each false
#        positive file, the user can choose to whitelist it. The script
#        then adds the file name, size and checksum to this whitelist
#        file. If a file is whitelisted it won't be shown to the user
#        again in the future, but the script will only add a notice to
#        the scan report. Please note that whitelisting a file by 
#        mistake can defeat the whole pourpose of this script, so pay
#        attention before whitelisting a file and, if you are not sure,
#        you better avoid whitelisting anything. This file needs to be
#        writeable for you to whitelist anything. <br/>
#        It defaults to $HOME/.findmalware/whitelist.local
#
#   -W _upstream-whitelist-file_ <br/>
#        same as -w, but it specifies a local copy of a upstream
#        whitelist, possibly downloaded from the internet. This can be
#        a read-only file, but if you use the autoupdate feature
#        (-a option), then this file and its parent directory need
#        to be writeable. <br/>
#        Please note that downloading random whitelists from unknown
#        sources for sake of saving some time during scans paves the 
#        way to a slow and painful death. And no, you should NOT
#        trust the official upstream whitelist published by the author 
#        of this script either, unless you have a good reason. <br/>
#        And please note that the author of this documentation is
#        the same as the author of the script, and he is the one who
#        publishes the default upstream whitelist too. In other words:
#        do NOT trust ME, where "ME"="Lucio Crusca", your faithful 
#        author of the script who has written this stuff. <br/>
#        I'm not saying I'm so bad, but I can make mistakes and you 
#        can't hold me liable for that. You have been warned.
#        That being said, this script works for me and I trust myself,
#        so this script has the autoupdate feature enabled by default
#        and it downloads my whitelist by default. <br/>
#        This option defaults to $HOME/.findmalware/whitelist
# 
#   -r _local-rules-file_ <br/>
#        specifies a file containing rules, one per line. Rules are 
#        regular expressions as recognized by grep. PHP files matching
#        one or more rules are considered infected and shown to the
#        user during scans. If you want to use more rules than the 
#        default ones, you can write them in a file and pass the file
#        to the script with this option. 
#        It defaults to $HOME/.findmalware/rules.local
#
#   -R _upstream-rules-file_ <br/>
#        same as -r, but it specifies a local copy of a upstream 
#        rules file, possibly downloaded from the internet. If you use 
#        the autoupdate feature (-a option), then this file and its parent 
#        directory need to be writeable. <br/>
#        All the -W advices apply, so go read them if you haven't yet. <br/>
#        It defaults to $HOME/.findmalware/rules
#
#   -u _upstream-url_ <br/>
#        specifies the URL to use when autoupdating local copies 
#        of upstream files. <br/>
#        When autoupdating, this script looks for the following files
#        online:
#          * upstream-url/whitelist-latest.txt
#          * upstream-url/blacklist-latest.txt
#          * upstream-url/rules-latest.txt
#        It uses _curl_ to check last modification date online and to 
#        download them if needed. <br/>
#        It defaults to https://webcloud.virtualbit.it/findmalware
#
#   -e _extensions-list_  <br/>
#        specifies the comma-separated list of file extensions to consider. <br/>
#        If you use this option, remember to include the default php too, unless
#        you really want to avoid files ending in ".php". Example: <br/>
#
#           -e php,php4,php5,php7
#
#        This script was initially intended to look for malicious code in PHP files
#        only, but there is nothing in the code that prevents its use for other type
#        of files, so you can use this option to specify any extension you like. 
#        Please note however that, as of time of this writing, the whitelists, 
#        blacklists and rules provided by default make sense only for PHP files, 
#        but you can always use different lists than the default ones. <br/>
#        It defaults to php only.
#
#   -a _[on|off]_ <br/>
#        enables or disables the autoupdate of the lists and rules. 
#        It's enabled by default, for reasons you can find in the -W 
#        documentation above. Haven't read that yet?
#   
#   -A _[on|off]_ <br/>
#        enables or disables the autoupdate of the script code
#        itself. Defaults to "off". The "on" value is not implemented yet.
#
#   -h <br/>
#        shows this help and exits.
#
#   -m <br/>
#        shows this help in markdown format and exits.
#
#
# ### Configuration files:
#
#   All options except "-h" and "-m" have a matching variable 
#   inside the script, so you can set them in configuration 
#   files too, but see below for "-c". <br/>
#   Here is the list of variables and their respective 
#   controlling option. Options, if specified, take precedence 
#   over configuration files. <br/>
#   Environment variables by the same name of these ones are
#   silently ignored. <br/>
#
#     *  AUTOUPDATE\_LISTS is controlled by -a
#     *  AUTOUPDATE\_SCRIPT is controlled by -A
#     *  BLACKLIST\_ADDITIONS is controlled by -b
#     *  UPSTREAM\_BLACKLIST is controlled by -B
#     *  RULES\_ADDITIONS is controlled by -r
#     *  UPSTREAM\_RULES is controlled by -R
#     *  URL\_FOR\_UPSTREAM\_LISTS is controlled by -u
#     *  WHITELIST\_ADDITIONS is controlled by -w
#     *  UPSTREAM\_WHITELIST is controlled by -W
#     *  EXTENSIONS\_LIST is controlled by -e
#     *  USERCONFFILE is controlled by -c, but...
#       
#   Additionally you can define the FINDMALWARE\_CONFIG variable
#   in your environment end export it to this script before 
#   running it. Doing so will cause the specified value to be used
#   as initialization for USERCONFFILE. <br/>
#   Default configuration files can do whatever they see fit in
#   variables values, including USERCONFFILE. <br/>
#   Thus, it is theoretically possible to assign a value
#   to USERCONFFILE inside one of the default configuration files,
#   causing the specified conf-file to be loaded afterwards,
#   but I suspect it makes little sense to do so.
#
# {{{ENDHELP}}}

function show_help
{
  show_markdown | sed -E -e 's- <br/>--g' -e 's/_([^\s_]*)_/\1/g' -e 's/\*\*([^\s*]*)\*\*/\1/g' -e 's/\\_/_/g'
}

function show_markdown
{
  STARTLINE=$(cat "$0" | grep -n '{{{STARTHELP}}}' | head -n1 | cut -d: -f1)
  STARTLINE=$(($STARTLINE + 1))
  ENDLINE=$(cat "$0" | grep -n '{{{ENDHELP}}}' | head -n1 | cut -d: -f1)
  ENDLINE=$(($ENDLINE - 1))
  cat "$0" | head -n "$ENDLINE" | tail -n +"$STARTLINE" | sed -e 's/^#//' -e 's/^ //'
}

USERCONFDIR="$HOME/.findmalware"
USERCONFFILE="$USERCONFDIR/config"
UPSTREAM_WHITELIST="$USERCONFDIR/whitelist"
UPSTREAM_BLACKLIST="$USERCONFDIR/blacklist"
UPSTREAM_RULES="$USERCONFDIR/rules"
WHITELIST_ADDITIONS="$USERCONFDIR/whitelist.local"
BLACKLIST_ADDITIONS="$USERCONFDIR/blacklist.local"
RULES_ADDITIONS="$USERCONFDIR/rules.local"
URL_FOR_UPSTREAM_LISTS="https://webcloud.virtualbit.it/findmalware"
EXTENSIONS_LIST="php"
AUTOUPDATE_LISTS="on"
AUTOUPDATE_SCRIPT="off"

# The options
OPTIONS="a:A:b:B:c:e:hmr:R:u:w:W:"

function check_custom_config()
{
  CUSTOMCONFIGFILE="$1"
  if [ -r "$CUSTOMCONFIGFILE" ] ; then
    USERCONFFILE="$CUSTOMCONFIGFILE"
  else
    echo "$CUSTOMCONFIGFILE is not readable, aborting."
    exit 1
  fi
}

if ! [ -z ${FINDMALWARE_CONFIG+x} ]; then 
  check_custom_config "$FINDMALWARE_CONFIG"
fi

# We process the '-c configfile' opion first, because other command line options
# override config file settings, so we need to apply those options afterwards

while getopts $OPTIONS OPT ; do
    case $OPT in
        c)
            check_custom_config "$OPTARG"
            ;;
    esac
done

# Now include all the configuration files

for FMCONFIG in "/etc/findmalware.conf" "/usr/local/etc/findmalware.conf" "$HOME/.findmalware.conf" "$HOME/.config/findmalware.conf" "$USERCONFFILE" ; do
  if [ -r "$FMCONFIG" ] ; then
    source "$FMCONFIG"
  fi
done

# Then we process remaining command line options (we need to reset OPTIND in order to make getopts work again)
OPTIND=1

while getopts $OPTIONS OPT ; do
    case $OPT in
        a)
            AUTOUPDATE_LISTS="$OPTARG"
            ;;
        A)
            AUTOUPDATE_SCRIPT="$OPTARG"
            ;;        
        b)
            BLACKLIST_ADDITIONS="$OPTARG"
            ;;
        B)
            UPSTREAM_BLACKLIST="$OPTARG"
            ;;
        r)
            RULES_ADDITIONS="$OPTARG"
            ;;
        R)
            UPSTREAM_RULES="$OPTARG"
            ;;
        w)
            WHITELIST_ADDITIONS="$OPTARG"
            ;;
        W)
            UPSTREAM_WHITELIST="$OPTARG"
            ;;
        h)
          show_help
          exit 0
            ;;
	m) 
          show_markdown
	  exit 0
	    ;;
        u)
            URL_FOR_UPSTREAM_LISTS="$OPTARG"
            ;;
	e)
            EXTENSIONS_LIST="$OPTARG"
	    ;;
    esac
done

if [ "$AUTOUPDATE_SCRIPT" == "on" ] ; then
  echo "-A is not implemented yet"
  exit 2
fi

function update_single_resource
{
  FM_LOCAL_RESOURCE="$1"
  FM_REMOTE_RESOURCE="$2"
  FM_LABEL="$3"
  FM_PARENTDIR=$(dirname "$FM_LOCAL_RESOURCE")
  mkdir -p "$FM_PARENTDIR" 2>/dev/null
  if ! [ -r "$FM_LOCAL_RESOURCE" ] ; then
    echo "Fetching $FM_LABEL from upstream"
    curl -o "$FM_LOCAL_RESOURCE" "$FM_REMOTE_RESOURCE" >/dev/null 2>&1
  else
    echo "Checking for $FM_LABEL updates"
    curl -o "$FM_LOCAL_RESOURCE" -z "$FM_LOCAL_RESOURCE" "$FM_REMOTE_RESOURCE" >/dev/null 2>&1
  fi
}

function update_lists
{
  update_single_resource "$UPSTREAM_BLACKLIST" "$URL_FOR_UPSTREAM_LISTS/blacklist-latest.txt" "blacklist"
  update_single_resource "$UPSTREAM_WHITELIST" "$URL_FOR_UPSTREAM_LISTS/whitelist-latest.txt" "whitelist"
  update_single_resource "$UPSTREAM_RULES" "$URL_FOR_UPSTREAM_LISTS/rules-latest.txt" "rules"
}

if [ "$AUTOUPDATE_LISTS" == "on" ] ; then
  update_lists
fi

function build_resource
{
  FM_UPSTREAM_RES="$1"
  FM_LOCAL_RES="$2"
  FM_RESOURCE="$3"
  cat "$FM_UPSTREAM_RES" > "$FM_RESOURCE"
  if [ -r "$FM_LOCAL_RES" ] ; then
    cat "$FM_LOCAL_RES" >> "$FM_RESOURCE"
  fi
}

FM_WHITELIST=$(mktemp)
FM_BLACKLIST=$(mktemp)
FM_RULES=$(mktemp)

build_resource "$UPSTREAM_WHITELIST" "$WHITELIST_ADDITIONS" "$FM_WHITELIST"
build_resource "$UPSTREAM_BLACKLIST" "$BLACKLIST_ADDITIONS" "$FM_BLACKLIST"
build_resource "$UPSTREAM_RULES" "$RULES_ADDITIONS" "$FM_RULES"

SCANREPORT=$(mktemp)

for EXT in $(echo "$EXTENSIONS_LIST" |tr ',' ' ') ; do
  echo "Looking for mailware in $EXT files. It can take a while, please wait..."
  FILELIST=$(mktemp)
  find . -iname \*.$EXT -type f -exec grep -rln -f "$FM_RULES" \{\} \; > "$FILELIST"
  PROCESSEDFILES=0
  TOTFILES=$(cat "$FILELIST" | wc -l)
  for F in $(cat "$FILELIST") ; do 
	PROCESSEDFILES=$(($PROCESSEDFILES + 1))
        FNAMEONLY=$(basename "$F")
        FSIZE=$(du -bs "$F" | tr '\t' ' ' | tr -s ' ' | cut -d' ' -f1)
	SHA512=$(cat "$F" | sha512sum | cut -d' ' -f1)
	
	WHITELISTED=$(cat "$FM_WHITELIST" | grep "SIZE=$FSIZE SHA512=$SHA512" | wc -l)

	if [ $WHITELISTED -eq 0 ] ; then
                ALREADYBLACKLISTED=$(cat "$FM_BLACKLIST" | grep "SIZE=$FSIZE SHA512=$SHA512" | wc -l)
                if [ $ALREADYBLACKLISTED -eq 0 ] ; then
			SCREEN_COMMANDS=$(mktemp)
			echo "split" > "$SCREEN_COMMANDS"
			echo "screen 1 /bin/sh -c 'less \"$F\" ; screen -S \"\${STY}\" -X quit'" >> "$SCREEN_COMMANDS"
			echo "focus down" >> "$SCREEN_COMMANDS"
			# echo "resize 8" >> "$SCREEN_COMMANDS"
			echo "screen 2" >> "$SCREEN_COMMANDS"
			echo "exec !.. grep -n -o -f \"$FM_RULES\" \"$F\"" >> "$SCREEN_COMMANDS"
       			echo "focus up" >> "$SCREEN_COMMANDS"
	                screen -S review -c "$SCREEN_COMMANDS"
                        rm -f "$SCREEN_COMMANDS"
			echo "Processing file $PROCESSEDFILES of $TOTFILES"
			echo -n "Mark $F as infected? (y/N): " 
			read D 
			D=$(echo $D | tr 'A-Z' 'a-z')
		else
			D="y"
		fi
		if [ "$D" == "y" ] ; then 
			if [ $ALREADYBLACKLISTED -eq 0 ] ; then
				echo "SIZE=$FSIZE SHA512=$SHA512" >> "$FM_BLACKLIST"
				echo "SIZE=$FSIZE SHA512=$SHA512" >> "$BLACKLIST_ADDITIONS"
				echo $(realpath "$F") '******INFECTED******' >> "$SCANREPORT"
			else
				echo $(realpath "$F") '******INFECTED****** (previously BLACKLISTED)' >> "$SCANREPORT"
			fi
		else
			echo -n "Whitelist $F? (Y/n): "
			read W
			W=$(echo $W | tr 'A-Z' 'a-z')
			if [ "$W" != "n" ] ; then
				echo $(realpath "$F") '!!!!!!WHITELISTED!!!!!!' >> "$SCANREPORT"
				echo "NAME='$FNAMEONLY' SIZE=$FSIZE SHA512=$SHA512" >> "$FM_WHITELIST"
				echo "NAME='$FNAMEONLY' SIZE=$FSIZE SHA512=$SHA512" >> "$WHITELIST_ADDITIONS"
			fi
		fi 
	else
		NAMEMATCHES=$(cat "$FM_WHITELIST" | grep "NAME='$FNAMEONLY' SIZE=$FSIZE SHA512=$SHA512" | wc -l)
		if [ $NAMEMATCHES -eq 0 ] ; then
			WLNAME=$(cat "$FM_WHITELIST" | grep "SIZE=$FSIZE SHA512=$SHA512" | cut -d\' -f2)
			echo "$F is already whitelisted under different name: $WLNAME"
		else
			echo "$F is already whitelisted"
		fi
		echo $(realpath "$F") '~~~~~~IGNORED~~~~~~ (previously WHITELISTED)' >> "$SCANREPORT"
	fi
  done
done

FM_INFECTED_COUNT=$(cat "$SCANREPORT" | grep '\*\*\*\*\*\*INFECTED\*\*\*\*\*\*' | wc -l)

if [ $FM_INFECTED_COUNT -gt 0 ] ; then
        echo "List of INFECTED PHP files I have found:"
        echo "----------------------------------------"
        echo
	cat "$SCANREPORT" | grep '\*\*\*\*\*\*INFECTED\*\*\*\*\*\*'
        echo
else
	echo "I couldn't find any known malware sign. It does NOT necessarily mean there isn't."
fi

echo "You can find the full report in $SCANREPORT"

